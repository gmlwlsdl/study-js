# 4-1. 변수란 무엇인가?

변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.

메모리는 메모리 셀의 집합이고, 메모리 셀은 데이터를 저장할 수 있는 장소이다. <br />
메모리 셀 하나의 크기는 **1Byte** 이고, 컴퓨터는 메모리 셀의 크기를 단위로 데이터를 읽고 저장한다. <br />
따라서 각 셀은 고유의 메모리 주소를 가진다.

그런데! 예를 들어, 10 + 20 = 30 이라는 값을 각각 메모리에 저장했는데 30에 접근하고 싶다면? <br />
사용자가 직접 메모리 주소를 통해 값에 접근하는 건 오류를 발생시킬 가능성이 높기 때문에 JS는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

그리고 코드가 다 돌아가고 나서야 데이터가 메모리에 저장되기 때문에, 미리 코드에 메모리 주소를 적어두고 접근할 수도 없다.

그래서 JS는 변수라는 메커니즘을 이용한다. <br >
변수는 **하나의 값을 저장하기 위해 확보한 메모리 공간 자체이고, 그 공간들을 식별하기 위해 붙인 이름이다.**

변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
<br />

# 4-2. 식별자란? (Identifier)

식별자는 **어떤 값을 구별해서 식별할 수 있는 고유한 이름이다.** ~~(사람을 이름으로 구별하는 것과 같다.)~~

값은 메모리 공간에 저장되어야 한다. 따라서 식별자는 값이 아니라, 메모리 주소를 기억하고 있어야 한다. <br />
-> 식별자로 값을 구별해서 식별한다는 것은, 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.

따라서 `식별자 === 메모리 주소` 라고 할 수 있다.

변수, 함수, 클래스 등의 이름은 모두 식별자이다. <br />
메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자이다.
식별자는 네이밍 규칙을 준수해야 하고, 선언(declaration)에 의해 JS 엔진에 식별자의 존재를 알려야 한다.
<br />

# 4-3. 변수 선언 (Variable Declaration)

변수를 생성하는 것이다.

값을 저장하기 위한 메모리 공간을 **확보(allocate)** 하고, <br />
변수 이름과 확보된 **메모리 공간의 주소를 연결(name binding)** 해서 <br />
값을 저장할 수 있게 준비하는 것이다.

변수 선언에 의해 확보된 메모리 공간은 **확보가 해제(release)** 되기 전까지 보호되므로 안전하게 사용된다.

변수를 사용하려면 반드시 선언이 필요하므로 `var`, `let`, `const` 키워드를 사용한다. <br />

ES6에서 `let`, `const` 키워드가 도입되기 전까지 `var` 키워드는 JS에서 유일한 변수 선언이 가능한 키워드였다.

> ES6 vs ES5
> ES6는 하위 호환성을 유지하면서 ES5 기반 위에 새로운 기능이 추가된 것이다.
> var는 block-level scope를 지원하지 않고, function-level scope를 지원하므로 의도치 않게 전역 변수가 설정되어 부작용이 발생할 수 있다.
>
> > ```js
> > var y = 1
> >
> > if (true) {
> >   var x = 10
> >   var y = 1000000
> > }
> >
> > console.log(x) // 10 -> block-level scope 지원 x
> > console.log(y) // 1000000 -> 전역 변수 오염!
> > ```

<br />

var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 **"키워드"** 이다. <br />
JS 엔진은 키워드를 만나면 자신이 수행하기로 약속한 동작을 수행한다.

변수를 선언하고 아직 변수에 값을 할당하지 않았으면, 변수 선언에 의해 확보된 메모리 공간은 비어있지 않고! <br />
JS 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화 된다. <br />
**undefined는 JS에서 제공하는 원시 타입의 값(primitive value)** 이다.

JS 엔진의 변수 선언 단계는 다음과 같다.

1. 선언 단계: 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 Undefined를 할당해 초기화한다.

그럼 변수 이름은 어디에 등록될까? <br />
변수 이름을 비롯한 모든 식별자는 **실행 컨텍스트(Execution Context)** 에 등록된다. <br />
JS 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다. <br />
변수 이름과 값은 Key-Value 형식의 객체로 등록되어 관리된다.

`var` 키워드는 변수 선언, 초기화가 동시에 진행된다. <br />
일반적으로 초기화는 변수가 선언되고 최초로 값을 할당하는 걸 말하는데, `var`는 기본적으로 선언과 동시에 undefined가 할당되어서 초기화가 진행된다.

초기화 단계를 거치지 않으면, 이전에 사용했던 값이 남아서 **쓰레기 값(garbage value)** 가 남아있게 된다. <br />
따라서 메모리 공간을 확보하고 값을 할당하지 않고 바로 변수를 참조하면 쓰레기 값이 나올 수도 있다. <br />
`var`는 이런 면에서 안전하다고 볼 수 있겠다!

변수를 사용하려면 반드시 선언이 필요하고, 선언하지 않은 식별자에 접근하면 **ReferenceError(참조 에러)** 가 발생한다.
<br />

# 4-4. 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score) //undefined
var score // 변수 선언문
```

위 코드는 변수 선언문보다 참조 코드가 앞에 있다. <br />
JS 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 `console.log`를 실행할 때 ReferenceError가 발생할 거 같지만 undefined가 출력된다.

변수 선언은 런타임이 아니라, 그 이전 단계인 **"평과 과정"** 에서 실행되기 때문이다.<br />
JS 엔진은 평과 과정에서 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스 코드에서 찾아내어 먼저 실행한다. <br />
그리고 평과 과정이 끝나면, 모든 선언문ㅇ르 제외하고 소스 코드를 한 줄씩 순차적으로 실행한다. <br />
이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유 특징을 **변수 호이스팅(Variable hoisting)** 이라고 한다.

> var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자는 모두 호이스팅 된다.

<br />

# 4-5. 값의 할당

변수에 값을 할당(assignment)할 때는 할당 연산자를 사용한다.

```js
console.log(score) // undefined

var score // 변수 선언
score = 80 // 변수 할당

console.log(score) // 80
```

or

```js
console.log(score) // undefined

var score = 80 // 변수 선언과 값의 할당

console.log(score) // 80
```

변수 선언과 할당을 하나의 문장으로 단축해도, JS는 선언과 할당 2개의 문으로 나눠서 실행한다.

그런데 변수에 값을 할당할 때는 이전 값(undefined)가 저장되어 있던 공간을 지우고 새로운 값을 저장하는 게 아니라, 새로운 메모리 공간을 확보하고 거기에 값을 할당한다!
<br />

# 4-6. 값의 재할당

재할당이란, 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것이다. <br />
현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.

근데 var는 애초에 선언하면 undefined로 값이 초기화 되므로, 변수에 처음으로 값을 할당하는 것도 사실… 재할당임!!!!@#!@#!

값을 재할당할 수 없어서 변수에 저장한 값을 변경할 수 없으면 **상수** 라고 한다.<br />

> 그럼 `const`는 상수라고 해야 하지 않나?
> `const`는 참조의 불변성을 보장할 뿐, 값의 불변성을 보장하지는 않는다.
>
> > ```js
> > const PI = 3.14
> > PI = 3.14159 // TypeError: Assignment to constant variable.
> > ```
>
> 위처럼 원시 타입인 경우에는 상수처럼 동작하지만
>
> > ```js
> > const cutie = {
> >   name: 'chiikawa',
> >   type: 'hamster',
> > }
> >
> > person.name = 'hachiware' // 내부 속성은 변경 가능
> > console.log(cutie) // { name: "hachiware", type: "hamster" }
> >
> > cutie = {} // TypeError: Assignment to constant variable.
> > ```
>
> 객체나 배열의 데이터는 수정하거나 추가하는 것은 가능하다.

변수에 값을 재할당하면 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장한다. <br />
그럼 필요 없어진 메모리 공간은? -> **가비지 콜렉터(Garbage collector)** 에 의해 자동으로 메모리에서 해제된다. <br />
하지만 언제 해제될지는 예측할 수 없다.

> Garbage collector는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능이다. JS는 Garbage collector를 내장하고 있는 managed 언어이다.

<br />

> managed 언어란?
>
> > 개발자의 직접적인 메모리 제어를 허용하지 않는 언어를 의미한다.
> > 반대로 C언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc과 free 같은 메모리 제어 기능을 제공한다.
> > 이는 메모리 제어를 개발자가 주도할 수 있으므로, 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 치명적인 오류를 생산할 수도 있는 단점이 존재한다.

<br />

# 4-7. 식별자 네이밍 규칙

식별자는 어떤 값을 구별해서 식별해내는 고유한 이름이므로, 다음과 같은 네이밍 규칙을 준수해야 한다.

- 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 특수문자를 제외한 문자, 언더스토어(\_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 건 안 된다!
- 예약어는 식별자로 사용할 수 없다. (프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어)

ES6부터 식별자를 만들 때 유니코드 문자를 허용해서 알파벳 외에도 한글, 일본어 사용이 가능해졌다. <br />
근데 알파벳 외의 문자로 식별자를 명명하는 것은 권장되지 않는다. _(코드 가독성 이슈, 호환성 이슈 등)_ <br />

변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다. <br />
따라서 네이밍 컨벤션(Naming Convection)을 정해두고 사용하는 것이 좋다!

네이밍 컨벤션은 하나 이상의 영어 단어로 구성된 식별자를 만들 때, 가독성 향상을 위해 명명한 규칙이다.

- camelCase (ex. firstName)
- snake_case (ex. first_name)
- PascalCase (ex. FirstName)
- typeHungarianCase (ex. strFirstName)

JS는 일반적으로 변수/함수 이름은 camelCase를 이용하고, <br />
생성자 함수/클래스 이름에는 PascalCase를 이용한다.
